<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Data Struct Summary(Algorithms in C Chapter 2)</title>
    <url>/2020/09/22/Algorithms_IN_C/part2/</url>
    <content><![CDATA[<p>关系图:</p>
<a id="more"></a>
<h4 id="基本数据结构"><a class="markdownIt-Anchor" href="#基本数据结构"></a> 基本数据结构</h4>
<p>这里介绍了C语言中提供的最基本的数据结构，其是后续构造更复杂数据结构的基础，实际可以理解为也是一种C基于机器语言上提供的一个抽象（这里抽象的概念在计算机体系中十分通用，表明了一种层次性，对于每一层上都有一个相应的抽象模型）</p>
<ul>
<li>主要介绍了数组、链表、复合数据结构（struct）</li>
<li>数组就很基本用法</li>
<li>链表 基于指针和复合数据结构即可以实现 或者 基于数组实现(本质上是一种抽象)</li>
<li>关于链表的相关操作以及概念
<ul>
<li>链表遍历、删除、增加</li>
<li>链表求逆（需要同时维护三个节点）</li>
<li>注意有无哑元节点情况下的操作</li>
</ul>
</li>
<li>书中还提到基于链表这种动态变化的特点实现的一种简单版本的malloc函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基于指针的实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> node * link;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="comment">//Item Means any data struct</span></span><br><span class="line">    Item item;</span><br><span class="line">    link next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// init</span></span><br><span class="line">link beg_link = (link)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br></pre></td></tr></table></figure>
<ul>
<li>字符串（这里主要注意 C中操作字符串主要是处理字符串指针）</li>
<li>复合数据结构（
<ul>
<li>多维矩阵（多维数组或是多维链表的实现）</li>
<li>图（邻接矩阵 或是邻接表的实现）</li>
</ul>
</li>
<li>最后是一个二维数组的链表的实例（降低算法时间复杂度）</li>
</ul>
<h4 id="抽象数据类型"><a class="markdownIt-Anchor" href="#抽象数据类型"></a> 抽象数据类型</h4>
<p>这里涉及了一个ADT的概念，即抽象数据类型（也就是前述的一种抽象层次上的描述，表征一种抽象操作）</p>
<ul>
<li>ADT一般来说都通过提供的接口函数对对象集合进行操作，而不是直接操作内部对象</li>
<li>同一个ADT本质抽象概念相同，但是实现可以不同</li>
</ul>
<p>之后主要介绍了堆栈以及相应的FIFO队列</p>
<ul>
<li>
<p>stack （集合先进后出）</p>
<ul>
<li>基本操作（init、push、pop())</li>
<li>实现（数组和列表的实现)</li>
<li>应用（后缀表达式的求解 、中缀表达式转后缀表达式）</li>
</ul>
</li>
<li>
<p>FIFO （队列先进先出）</p>
<ul>
<li>实现（数组实现，链表实现）</li>
</ul>
</li>
<li>
<p>广义队列的概念（</p>
<ul>
<li>本质上堆栈和队列都可以看成一种广义队列，只是具有不同的删除规则</li>
<li>优先队列、双端队列</li>
<li>符号表（map）</li>
</ul>
</li>
</ul>
<p>数组可以看成是一个特殊的符号表：项本身就是索引值</p>
<p>实际上后续学习的这些数据结构都是一簇ADT，有着不同定以的操作接口，我们需要找寻他们的一种高效实现。</p>
<h4 id="递归-树-图仅遍历"><a class="markdownIt-Anchor" href="#递归-树-图仅遍历"></a> 递归、树、图（仅遍历）</h4>
<ul>
<li>
<p>这里将递归、树、图放在一起的原因我觉得是树这种数据结构与递归很类似（大问题基于小问题构成，树拆分其中一部分也还是一颗树，因此基于树的数据结构的一些算法常常可以用递归的方式进行实现，当然也能非递归实现，比如基于前述的栈、队列）</p>
</li>
<li>
<p>链表的一些操作也适合用递归完成，链表可以看成一个特殊的树，每个结点只有一个分支</p>
</li>
<li>
<p>递归的一些应用</p>
<ul>
<li>求公约数</li>
<li>前缀表达式求值</li>
</ul>
</li>
<li>
<p>分治法 （hanoi塔）</p>
<ul>
<li>hanoi 本质上会产生2^N - 1 的移动 ，由其递推公式可以得到(TN = 2 * TN-1  +1)</li>
<li>基于分治算法的范型包括如快速排序、归并排序、二分搜索等算法</li>
<li>分治算法揭示了一个非常基础的原理在于将问题分半（或者多个），将大问题分解为子问题进行求解</li>
</ul>
</li>
</ul>
<h5 id="动态规划本质也是将一个问题分解为多个子问题进行求解但是不同之处在于分解的子问题可能存在重复"><a class="markdownIt-Anchor" href="#动态规划本质也是将一个问题分解为多个子问题进行求解但是不同之处在于分解的子问题可能存在重复"></a> 动态规划（本质也是将一个问题分解为多个子问题进行求解，但是不同之处在于分解的子问题可能存在重复）</h5>
<ul>
<li>以斐波那契数列数列和背包问题为例</li>
<li>动态规划关键在于分解子问题（找出递推关系 及 原问题和子问题之间的联系）以及 存储已求子问题的解防止重复求解</li>
<li>自底向上的动态规划（非低轨，循环外推）</li>
<li>自顶向上的动态规划（递归版本）<br>
(斐波那契数列问题)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// no recursion version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonaci1</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// f46 have the max value can be storaged by int</span></span><br><span class="line">  <span class="keyword">int</span> F[<span class="number">46</span>];</span><br><span class="line">  F[<span class="number">0</span>] =<span class="number">1</span>;</span><br><span class="line">  F[<span class="number">1</span>] =<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;=i;i++)&#123;</span><br><span class="line">    F[i] = F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> F[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursion version</span></span><br><span class="line"><span class="keyword">int</span> known[<span class="number">46</span>];</span><br><span class="line"><span class="built_in">memset</span>(known,<span class="number">-1</span>,<span class="keyword">sizeof</span>(known));</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibnoci2</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (known[i]!=<span class="number">-1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> known[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i==<span class="number">0</span> || i==<span class="number">1</span>)&#123;</span><br><span class="line">      known[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      known[i] = fibnoci2(i<span class="number">-1</span>) + fibnoci2(i<span class="number">-2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> known[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>背包问题
</code></pre>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">item</span>&#123;</span></span><br><span class="line">  <span class="keyword">int</span>  value;</span><br><span class="line">  <span class="keyword">int</span>  size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N=<span class="number">100</span>;</span><br><span class="line">item Item[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> MaxKnown[Max_M];</span><br><span class="line"><span class="built_in">memset</span>(Memset,<span class="number">-1</span>,<span class="keyword">sizeof</span>(MaxKnown));</span><br><span class="line"><span class="comment">// recursive version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knap</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(MaxKnown[M]!=<span class="number">-1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> MaxKnown[M];</span><br><span class="line">	&#125;</span><br><span class="line">	MaxKnown[M]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (M-Item[i].size &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			MaxKnown[M] = max(MaxKnown[M],knap(M-Item[i].size)+Item[i].value);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> MaxKnown[M];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no recursive version</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">knap_no_recursive</span><span class="params">(<span class="keyword">int</span> M)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span>* MaxKnown = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(M*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	<span class="built_in">memset</span>(MaxKnown,<span class="number">0</span>,<span class="keyword">sizeof</span>(MaxKnown));</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;M;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span>;j&lt;N;j++)&#123;</span><br><span class="line">			<span class="keyword">int</span> space = i+Item[j].size;</span><br><span class="line">			<span class="keyword">if</span> ( space&lt;=M )&#123;</span><br><span class="line">				MaxKnown[space] = max(MaxKnown[space],MaxKnown[i]+Item[j].value);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> MaxKnown[M];</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里 自顶向下的动态规划的优势在于 算法描述相对于解决问题十分自然，且可以自动确定待求解的子问题，个人觉得问题在于其一般采用递归实现，在解决较大递归深度情况下能力有限，如背包量十分大的背包问题，</li>
<li>自底向上的动态规划则采用循环实现，递归深度一般对于应数组存储，无函数调用开销，感觉能支持较大递归深度下的动态规划问题。</li>
</ul>
<h5 id="树"><a class="markdownIt-Anchor" href="#树"></a> 树</h5>
<ul>
<li>
<p>基本概念</p>
<ul>
<li>根节点、叶节点、二叉树</li>
<li>实现一般采用双向链表的方式表示</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> node *link;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> value;</span><br><span class="line"> link father;</span><br><span class="line"> link left_child;</span><br><span class="line"> link right_child;</span><br><span class="line"> <span class="comment">// or multi</span></span><br><span class="line"> link[<span class="number">10</span>] child_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里实现不采用类似前面的ADT的方式在于 树本身是用于实现其他高级ADT的基础</li>
<li>二叉树的数学性质：
<ul>
<li>具有N个内部节点的树具有N+1个的外部节点(外部节点是指不包含子节点的节点，剩余为内部节点)</li>
<li>N个内部节点的二叉树有2N个连接（实际就等于总节点数-1）N-1个内部链接 N+1个外部链接</li>
<li>N个内部节点的二叉树外部路径长度 比内部路径长度大2N （路径长度即为所有节点的层数之和，根节点为0层，层数最大值称为这颗树的高度）</li>
<li>N个内部节点的二叉树高度至多为N-1（感觉是N 感觉书上漏算了最后的外部节点的高度） 至少为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msub><mi>N</mi></mrow><annotation encoding="application/x-tex">\log_2N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.93858em;vertical-align:-0.24414em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.20696799999999996em;"><span style="top:-2.4558600000000004em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.24414em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span></span></span></span></li>
</ul>
</li>
<li>树的遍历
<ul>
<li>首先是三种遍历 前序 中序 后序 区分这三种顺序方式就是判断访问某个节点时候 本身节点与其子节点之间的访问顺序（其中前中后 分别表示本身节点的访问顺序）
<ul>
<li>前序 (本 左 右)</li>
<li>中序（左 中 右)</li>
<li>后序（左 右 中）</li>
</ul>
</li>
<li>实现（同样可以基于递归与非递归的方式，其中非递归基于栈数据结构即可以实现）
<ul>
<li>非递归的实现（在实现中、后序的时候 需要考虑将本节点的子节点压入堆栈后 指向空</li>
</ul>
</li>
<li>层序遍历（按层次进行节点的访问）
<ul>
<li>实现 基于队列的数据结构即可</li>
</ul>
</li>
<li>一些具体的应用：
<ul>
<li>求树节点树、高度（递归很容易完成）</li>
<li>中序 打印树的形状  前序 则遍历类似文件树或者目录树的结构</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="图的遍历"><a class="markdownIt-Anchor" href="#图的遍历"></a> 图的遍历</h5>
<ul>
<li>深度优先搜索 （注意到与树的前序遍历等价）</li>
<li>基于递归实现(有两种版本 直接存节点  和存指向节点的指针（更省空间）)
<ul>
<li>这里基于栈实现的需要注意一个问题 ，如果要实现等价于递归深度优先搜索邻接表的结果，需要将邻接表中的节点反向压入栈中（即链表尾的节点先压入栈），同为了避免大量重复的点的问题，可以将栈的数目固定为节点数，因为越之前存储的点，大概率会被提前访问过。</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> node * link;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    link next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">// number of Points</span></span><br><span class="line">link a[N]; </span><br><span class="line"><span class="keyword">int</span> v[N]; <span class="comment">//mark vist</span></span><br><span class="line"><span class="built_in">memset</span>(visit,<span class="number">0</span>,<span class="keyword">sizeof</span>(visit));</span><br><span class="line"></span><br><span class="line"><span class="comment">// recursion version</span></span><br><span class="line">void traverse(int k,void (*visit)(int))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (v[k] )&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*visit)(k);</span><br><span class="line">    v[k] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (link j=a[k];j!=<span class="literal">NULL</span>;j=j-&gt;next)&#123;</span><br><span class="line">        traverse(j-&gt;v,visit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no recursion version (based on stack)</span></span><br><span class="line">void traverse2(int k,void(*visit)(int))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    S.push(k);</span><br><span class="line">    <span class="keyword">while</span> (!S.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = S.top();</span><br><span class="line">        S.pop();</span><br><span class="line">        <span class="keyword">if</span> (v[k])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (*visit)(k);</span><br><span class="line">        v[k] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a[k];j!=<span class="literal">NULL</span>;j=j-&gt;next)&#123;</span><br><span class="line">            S.push(j-&gt;v); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>广度优先搜索( 类比于树中的层序遍历)</li>
<li>实现 (基于队列的版本)</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">void traverse_BFS(int k,void (*visit)(int))&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span><br><span class="line">    Q.push(k);</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Q.front();</span><br><span class="line">        Q.pop();</span><br><span class="line">        <span class="keyword">if</span> (v[t])&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        (*visit)(t);</span><br><span class="line">        v[t] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j =a[t];j!=<span class="literal">NULL</span>;j=j-&gt;next)&#123;</span><br><span class="line">            Q.push(j-&gt;v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CS</tag>
      </tags>
  </entry>
  <entry>
    <title>Uva 212 Solutions</title>
    <url>/2020/09/21/OJ/Uva212/</url>
    <content><![CDATA[<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>这里是Uva 212题解总结，这题卡了太久</p>
<a id="more"></a>
<h4 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h4><p>这里需要模拟一个医院手术室和恢复室的调度问题，题目给出所有手术室数量、恢复室数量、转移时间、开始时间、手术室准备时间、恢复室准备时间，以及各个病人的手术时间和恢复时间。</p>
<h4 id="样例输入输出"><a href="#样例输入输出" class="headerlink" title="样例输入输出"></a>样例输入输出</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sample input</span><br><span class="line">5 12 07 5 15 10 16</span><br><span class="line">Jones</span><br><span class="line">28 140</span><br><span class="line">Smith</span><br><span class="line">120 200</span><br><span class="line">Thompson</span><br><span class="line">23 75</span><br><span class="line">Albright</span><br><span class="line">19 82</span><br><span class="line">Poucher</span><br><span class="line">133 209</span><br><span class="line">Comer</span><br><span class="line">74 101</span><br><span class="line">Perry</span><br><span class="line">93 188</span><br><span class="line">Page</span><br><span class="line">111 223</span><br><span class="line">Roggio</span><br><span class="line">69 122</span><br><span class="line">Brigham</span><br><span class="line">42 79</span><br><span class="line">Nute</span><br><span class="line">22 71</span><br><span class="line">Young</span><br><span class="line">38 140</span><br><span class="line">Bush</span><br><span class="line">26 121</span><br><span class="line">Cates</span><br><span class="line">120 248</span><br><span class="line">Johnson</span><br><span class="line">86 181</span><br><span class="line">White</span><br><span class="line">92 140</span><br><span class="line">Sample output</span><br><span class="line">Patient Operating Room Recovery Room</span><br><span class="line"># Name Room# Begin End Bed# Begin End</span><br><span class="line">------------------------------------------------------</span><br><span class="line">1 Jones 1 7:00 7:28 3 7:33 9:53</span><br><span class="line">2 Smith 2 7:00 9:00 1 9:05 12:25</span><br><span class="line">3 Thompson 3 7:00 7:23 2 7:28 8:43</span><br><span class="line">4 Albright 4 7:00 7:19 1 7:24 8:46</span><br><span class="line">5 Poucher 5 7:00 9:13 5 9:18 12:47</span><br><span class="line">6 Comer 4 7:34 8:48 4 8:53 10:34</span><br><span class="line">7 Perry 3 7:38 9:11 2 9:16 12:24</span><br><span class="line">8 Page 1 7:43 9:34 6 9:39 13:22</span><br><span class="line">9 Roggio 4 9:03 10:12 9 10:17 12:19</span><br><span class="line">10 Brigham 2 9:15 9:57 8 10:02 11:21</span><br><span class="line">11 Nute 3 9:26 9:48 7 9:53 11:04</span><br><span class="line">12 Young 5 9:28 10:06 3 10:11 12:31</span><br><span class="line">13 Bush 1 9:49 10:15 10 10:20 12:21</span><br><span class="line">14 Cates 3 10:03 12:03 8 12:08 16:16</span><br><span class="line">15 Johnson 2 10:12 11:38 4 11:43 14:44</span><br><span class="line">16 White 5 10:21 11:53 7 11:58 14:18</span><br><span class="line">Facility Utilization</span><br><span class="line">Type # Minutes % Used</span><br><span class="line">-------------------------</span><br><span class="line">Room 1 165 29.68</span><br><span class="line">Room 2 248 44.60</span><br><span class="line">Room 3 258 46.40</span><br><span class="line">Room 4 162 29.14</span><br><span class="line">Room 5 263 47.30</span><br><span class="line">Bed 1 282 50.72</span><br><span class="line">Bed 2 263 47.30</span><br><span class="line">Bed 3 280 50.36</span><br><span class="line">Bed 4 282 50.72</span><br><span class="line">Bed 5 209 37.59</span><br><span class="line">Bed 6 223 40.11</span><br><span class="line">Bed 7 211 37.95</span><br><span class="line">Bed 8 327 58.81</span><br><span class="line">Bed 9 122 21.94</span><br><span class="line">Bed 10 121 21.76</span><br><span class="line">Bed 11 0 0.00</span><br><span class="line">Bed 12 0 0.00</span><br></pre></td></tr></table></figure>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><ul>
<li>手术结束时间相同的病人所在的手术室id较小的具有优先选择恢复室的权利</li>
<li>病人数为0时的输出（计算占用率会出现0除0的情况）</li>
<li>病人名可能会相同！！不能使用map进行存储（我就是这里卡了好久，以后这种键值会重复的一定要谨慎使用map，应考虑用不重复的id作为键值）</li>
<li>对于这种并行任务的模拟，和之前Uva822.cpp类似，推荐使用基于优先队列的时间池进行处理更为方便 （之前的方式是不断找最小的时间，本质就是优先队列）  </li>
</ul>
<h4 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h4><ul>
<li>这里clock_time实际有点累赘 直接存储minutes即可了<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">clock_time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    clock_time():</span><br><span class="line">        minutes(<span class="number">0</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    clock_time(<span class="keyword">int</span> hour):</span><br><span class="line">        minutes(hour*<span class="number">60</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    clock_time <span class="keyword">operator</span>+(<span class="keyword">int</span> Minutes) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        clock_time new_time;</span><br><span class="line">        new_time.minutes = <span class="keyword">this</span>-&gt;minutes + Minutes;</span><br><span class="line">        <span class="keyword">return</span> new_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> clock_time &amp; Other) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;minutes &lt; Other.minutes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;=(<span class="keyword">const</span> clock_time&amp; Other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;minutes &lt;= Other.minutes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> clock_time&amp; Other) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;minutes == Other.minutes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str_format</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hour = minutes / <span class="number">60</span>;</span><br><span class="line">        <span class="keyword">int</span> min = minutes - hour * <span class="number">60</span>;</span><br><span class="line">        <span class="built_in">stringstream</span> k;</span><br><span class="line">        k &lt;&lt; hour &lt;&lt; <span class="string">":"</span> &lt;&lt; setw(<span class="number">2</span>) &lt;&lt; setfill(<span class="string">'0'</span>) &lt;&lt; min;</span><br><span class="line">        <span class="keyword">return</span> k.str();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minutes;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> clock_time&amp; a,<span class="keyword">const</span> clock_time&amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.minutes &gt; b.minutes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">person_record</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> oerpate_id;</span><br><span class="line">    <span class="keyword">int</span> recover_id;</span><br><span class="line">    clock_time operate_beg;</span><br><span class="line">    clock_time operate_end;</span><br><span class="line">    clock_time recover_beg;</span><br><span class="line">    clock_time recover_end;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//ifstream fin("input.txt");</span></span><br><span class="line">    <span class="comment">//cin.rdbuf(fin.rdbuf());</span></span><br><span class="line">    <span class="keyword">int</span> num_operate, num_recover, beg_time, transport_time, preprare_operate, prepare_recover, num_patient;</span><br><span class="line">    <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; num_operate &gt;&gt; num_recover &gt;&gt; beg_time &gt;&gt; transport_time &gt;&gt; preprare_operate &gt;&gt; prepare_recover &gt;&gt; num_patient)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; person_info;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; person_list;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; person_prepare_list;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_patient;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> person_name;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; person_name;</span><br><span class="line">            person_prepare_list.push(i);</span><br><span class="line">            person_list.push_back(person_name);</span><br><span class="line">            <span class="keyword">int</span> operate_time,recover_time;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; operate_time &gt;&gt; recover_time;</span><br><span class="line">            person_info.push_back(make_pair(operate_time,recover_time));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">clock_time <span class="title">current_time</span><span class="params">(beg_time)</span></span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;clock_time&gt; operate_time_info(num_operate);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; operate_name(num_operate,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; operate_working(num_operate, <span class="literal">false</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;clock_time&gt; recover_time_info(num_recover);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; recover_name(num_recover,<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; recover_working(num_recover, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">vector</span>&lt;person_record&gt; record(num_patient);</span><br><span class="line">        priority_queue&lt;clock_time, <span class="built_in">vector</span>&lt;clock_time&gt;, cmp&gt; time_pool;</span><br><span class="line">        time_pool.push(current_time);</span><br><span class="line">        clock_time pre_time;</span><br><span class="line">        pre_time.minutes = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!time_pool.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            current_time = time_pool.top();</span><br><span class="line">            time_pool.pop();</span><br><span class="line">            <span class="keyword">if</span> (current_time == pre_time)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre_time = current_time;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// make sure all avilabe recover bed</span></span><br><span class="line">            <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; wait_for_recover;</span><br><span class="line">            <span class="comment">// get the person finish operating and all avliable operate room</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_operate;i++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (operate_time_info[i] &lt;= current_time &amp;&amp; operate_working[i])&#123;</span><br><span class="line">                    operate_working[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (operate_name[i] !=<span class="number">-1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        operate_working[i] = <span class="literal">true</span>;</span><br><span class="line">                        operate_time_info[i] = current_time + preprare_operate;</span><br><span class="line">                        wait_for_recover.push(operate_name[i]);</span><br><span class="line">                        operate_name[i] = <span class="number">-1</span>;</span><br><span class="line">                        time_pool.push(operate_time_info[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span> (!operate_working[i] &amp;&amp; !person_prepare_list.empty())&#123;</span><br><span class="line">                    operate_working[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> person_id = person_prepare_list.front();</span><br><span class="line">                    person_prepare_list.pop();</span><br><span class="line">                    record[person_id].oerpate_id= i + <span class="number">1</span>;</span><br><span class="line">                    record[person_id].operate_beg = current_time;</span><br><span class="line">                    record[person_id].operate_end = current_time + person_info[person_id].first;</span><br><span class="line">                    operate_time_info[i] = record[person_id].operate_end;</span><br><span class="line">                    operate_name[i] = person_id;</span><br><span class="line">                    time_pool.push(record[person_id].operate_end);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// get all availabe recover bed and move to recover</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num_recover; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (recover_time_info[i] &lt;= current_time &amp;&amp; recover_working[i])&#123;</span><br><span class="line">                    recover_working[i] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (recover_name[i] !=<span class="number">-1</span>)&#123;</span><br><span class="line">                        recover_working[i] = <span class="literal">true</span>;</span><br><span class="line">                        recover_time_info[i] = current_time + prepare_recover;</span><br><span class="line">                        recover_name[i] = <span class="number">-1</span>;</span><br><span class="line">                        time_pool.push(recover_time_info[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">                <span class="keyword">if</span> (!recover_working[i] &amp;&amp; !wait_for_recover.empty())&#123;</span><br><span class="line">                    recover_working[i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// move wait to the bed room;</span></span><br><span class="line">                    <span class="keyword">int</span> person_id= wait_for_recover.front();</span><br><span class="line">                    wait_for_recover.pop();</span><br><span class="line">                    record[person_id].recover_id = i + <span class="number">1</span>;</span><br><span class="line">                    record[person_id].recover_beg = current_time + transport_time;</span><br><span class="line">                    record[person_id].recover_end = current_time + transport_time + person_info[person_id].second;</span><br><span class="line">                    recover_time_info[i] = record[person_id].recover_end;</span><br><span class="line">                    recover_name[i] = person_id;</span><br><span class="line">                    time_pool.push(record[person_id].recover_end);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" Patient          Operating Room          Recovery Room"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" #  Name     Room#  Begin   End      Bed#  Begin    End"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" ------------------------------------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        clock_time beg;</span><br><span class="line">        beg.minutes = INT_MAX;</span><br><span class="line">        clock_time end;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; room_table;</span><br><span class="line">        <span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; bed_table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; person_list.size() ;i++)&#123;</span><br><span class="line">            <span class="built_in">string</span> person_name = person_list[i];</span><br><span class="line">            person_record&amp; record_person = record[i];</span><br><span class="line">            beg = min(record_person.operate_beg, beg);</span><br><span class="line">            end = max(record_person.recover_end, end);</span><br><span class="line">            room_table[record_person.oerpate_id]+= record_person.operate_end.minutes - record_person.operate_beg.minutes;</span><br><span class="line">            bed_table[record_person.recover_id]+= record_person.recover_end.minutes - record_person.recover_beg.minutes;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%2d  %-9s%3d   %5s   %5s     %2d   %5s   %5s\n"</span>,i+<span class="number">1</span>,person_name.c_str(),record_person.oerpate_id,record_person.operate_beg.str_format().c_str(),</span><br><span class="line">                record_person.operate_end.str_format().c_str(),record_person.recover_id,record_person.recover_beg.str_format().c_str(),</span><br><span class="line">                record_person.recover_end.str_format().c_str());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> total_minutes = (end.minutes-beg.minutes)/<span class="number">100.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Facility Utilization"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Type  # Minutes  % Used"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"-------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;num_operate;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num_patient==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-5s%2d%8d   %5.2f\n"</span>,<span class="string">"Room"</span>,i+<span class="number">1</span>,room_table[i+<span class="number">1</span>],<span class="number">0.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-5s%2d%8d   %5.2f\n"</span>,<span class="string">"Room"</span>,i+<span class="number">1</span>,room_table[i+<span class="number">1</span>],room_table[i+<span class="number">1</span>]/total_minutes);</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;num_recover;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (num_patient==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-5s%2d%8d   % 5.2lf\n"</span>,<span class="string">"Bed"</span>,i+<span class="number">1</span>,bed_table[i+<span class="number">1</span>],<span class="number">0.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%-5s%2d%8d   %5.2lf\n"</span>,<span class="string">"Bed"</span>,i+<span class="number">1</span>,bed_table[i+<span class="number">1</span>],bed_table[i+<span class="number">1</span>]/total_minutes);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>OJ</tag>
        <tag>Uva</tag>
      </tags>
  </entry>
  <entry>
    <title>Flask Study:Python mgic method and Local ocalStack ocalProxy in Werkzeug</title>
    <url>/2020/02/10/Flask-Study-Python-mgic-method-and-Local-LocalStack-LocalProxy-in-Werkzeug/</url>
    <content><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>本篇文章主要记录阅读Flask源码遇到的有关Local以及LocalProxy概念的问题的理解<br>FLask源码记录如下(globals.py)：<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalProxy</span><br><span class="line"><span class="keyword">from</span> werkzeug.local <span class="keyword">import</span> LocalStack</span><br><span class="line"></span><br><span class="line"><span class="comment">#.......</span></span><br><span class="line"><span class="comment">#somthing here</span></span><br><span class="line"><span class="comment">#.......</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># context locals</span></span><br><span class="line">_request_ctx_stack = LocalStack()</span><br><span class="line">_app_ctx_stack = LocalStack()</span><br><span class="line">current_app = LocalProxy(_find_app)</span><br><span class="line">request = LocalProxy(partial(_lookup_req_object, <span class="string">"request"</span>))</span><br><span class="line">session = LocalProxy(partial(_lookup_req_object, <span class="string">"session"</span>))</span><br><span class="line">g = LocalProxy(partial(_lookup_app_object, <span class="string">"g"</span>))</span><br></pre></td></tr></table></figure></p>
<p><strong>这里重要的是是声明了几个全局变量，current_app,request,g，这几个变量在flask使用中频繁出现，这里引入这些看似为全局变量的原因，本人理解，一个主要原因主要是为了后续视图函数中可以方便的调用本次如http请求过程中的相关参数，而无需传入参数进视图函数</strong><br>这里flask中的路由和视图函数声明过程如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@route("/index")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>其中index()函数即为视图函数</p>
<p>到这里，促使我了解上述全局变量的实现原理的原因在于，首先是开头那段代码完全看不懂在做什么，尤其出现了LocalStack、LocalProxy这些对象不知所云，后搜索发现，Werkzeug（Flask一个依赖的基础模块，wsui协议）中的Local模块中完成了一个十分重要的功能：</p>
<ul>
<li>上述的全局变量在多线程/协程环境中，对于各自线程/协程来说，这些全局变量是互相独立互不影响<br>因此本着学习Python语法的目的，想探究开头代码背后的实现原理</li>
</ul>
<h2 id="Python-继承、魔法方法"><a href="#Python-继承、魔法方法" class="headerlink" title="Python 继承、魔法方法"></a>Python 继承、魔法方法</h2><p>首先，先看Werkzeug的local模块中的源代码，一共有三个比较重要的类：Local、LocalStack、LocalProxy<br>首先看最基础的Local类，源代码如下:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Local</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__storage__'</span>, <span class="string">'__ident_func__'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">        object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self.__storage__.items())</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, proxy)</span>:</span></span><br><span class="line">        <span class="string">"""Create a proxy for a name."""</span></span><br><span class="line">        <span class="keyword">return</span> LocalProxy(self, proxy)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__release_local__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__storage__.pop(self.__ident_func__(), <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">        ident = self.__ident_func__()</span><br><span class="line">        storage = self.__storage__</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            storage[ident][name] = value</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            storage[ident] = &#123;name: value&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delattr__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">del</span> self.__storage__[self.__ident_func__()][name]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(name)</span><br></pre></td></tr></table></figure>
<h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><p>Object类，这个在python2中用于区分新式类和旧式类，即继承于Object类的为新式类，反之没有继承的为旧式类。新式类和旧式类的一大区别在于，object类声明了许多魔法属性和方法（magic method）这些方法非常有用，除此之外新式类和旧式类在多重继承上也有区别，具体可以搜索相关内容，这里主要说明下object类的概念。<br>而在Python3中所有的类都是继承于object类的，不论是否显示声明继承于Object类<br>可用下述代码测试是类是否继承了Object类的相关属性和方法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">test</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == __main__:</span><br><span class="line">    print(dir(test()))</span><br></pre></td></tr></table></figure></p>
<p>回到Local类的代码上，其中Local类的初始化函数中如下：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">      object.__setattr__(self, <span class="string">'__storage__'</span>, &#123;&#125;)</span><br><span class="line">      object.__setattr__(self, <span class="string">'__ident_func__'</span>, get_ident)</span><br></pre></td></tr></table></figure></p>
<p>这里有几个问题:</p>
<ul>
<li>通过object类名直接调用函数的含义</li>
<li><strong>setattr</strong>函数的含义</li>
</ul>
<h3 id="Python继承"><a href="#Python继承" class="headerlink" title="Python继承"></a>Python继承</h3><p>对于上述的第一个问题，即是调用父类的相应同名方法，这在子类构造函数需要调用父类的构造函数中尤为常见，但是这应该是比较老的写法，对于Python3来说，推荐使用super的写法<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">father</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Old Method(python2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sonA</span><span class="params">(father)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        father.__init__(self)</span><br><span class="line">        <span class="comment"># son init here</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Use super</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sonB</span><span class="params">(father)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(sonB,self).__init__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sonC</span><span class="params">(father)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super().__init__()</span><br></pre></td></tr></table></figure></p>
<h3 id="Python魔法方法"><a href="#Python魔法方法" class="headerlink" title="Python魔法方法"></a>Python魔法方法</h3><p>对于第二个问题，有关<strong>setattr</strong>函数的含义,这个是object类中定义的魔法方法，在某些特定情况下会调用这些函数，这里<strong>setattr</strong>即是在对象进行属性设定会调用该函数进行设定，具体的魔法方法可以参考下述链接：<br>参考着篇文章<a href="https://rszalski.github.io/magicmethods/#appendix1" target="_blank" rel="noopener">python magic method</a><br>里面对python的各种魔法方法都进行了详细介绍</p>
<p>这里又引出了第三个问题:<br><strong>Local类这里设置属性的时候为啥非要使用父类的object类？</strong><br>这里主要是为了避免无限递归造成的堆栈溢出错误<br>如果这里采用直接属性赋值的方式，即<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 这里实际上调用的是 self.__setattr()方法</span></span><br><span class="line">    self.storage = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, name, value)</span>:</span></span><br><span class="line">    ident = self.__ident_func__()</span><br><span class="line">    storage = self.__storage__</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        storage[ident][name] = value</span><br><span class="line">    <span class="keyword">except</span> KeyError:</span><br><span class="line">        storage[ident] = &#123;name: value&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，<strong>setattr</strong>方法中又调用了self.<strong>storage</strong>,在这里又会调用<strong>setattr</strong>的方法，陷入无限递归,因此这里必须调用原有的父类Object类中的设置属性的方法</p>
<h2 id="Local类、LocalStack类、LocalProxy类"><a href="#Local类、LocalStack类、LocalProxy类" class="headerlink" title="Local类、LocalStack类、LocalProxy类"></a>Local类、LocalStack类、LocalProxy类</h2><p>到这里，看懂这段Loal类的创建语法上已经没有问题了，接下来就是Local类的设计思路：<br>Local目的是为了实现在多线程/协程环境下能够提供单线程/协程环境内的的使用的全局变量（同名），因此Local实际上是封装了各个线程内的同名变量，并用线程/协程的id来区分，在获取的时候通过获取当前线程/协程的id来获取对应的变量。<br>其中可以看到storage即是Local类用于存储各个线程/协程变量的字典数据结构</p>
<p>LocalStack类则是基于Local实现的栈结构</p>
<p>LocalProxy则是实现了对local对象以及可执行函数的一个代理，即代理类会将所有受到的操作都转移给其代理对象进行，但是必须注意的是，这里不能直接对代理对象进行赋值（一开始的理解就卡在这里，以为赋值为其他后依然是对原代理对象进行操作，实际上并不是，因为如果进行赋值后，会在调用该操作的区域生成了同名的局部变量遮盖了原有的代理变量，因此这样的操作违反了本意，也无法对原有代理对象进行修改），一般需要通过原始的Local对象进行获取操作，或者是LocalStack类的对象。<br>结合具体使用LocalProxy的例子来看<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_local</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">""" Local实例的代理 """</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Request</span><span class="params">(object)</span>:</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,i)</span>:</span></span><br><span class="line">            self.a = i</span><br><span class="line"></span><br><span class="line">    l = Local()</span><br><span class="line">    my_test = LocalProxy(l, <span class="string">'my_test'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">job</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="comment"># Local().__storage__[线程/协程标识]['my_test'] = A()</span></span><br><span class="line">        <span class="comment">## 一般来说 每个线程一开始都会有对该变量进行赋值的一个操作,这个操作必须通过Local.对象的方式进行</span></span><br><span class="line">        l.my_test = Request(i)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># lp = __storage__[线程/协程标识]['my_test'], 即lp.a = 1 等价于 给当前线程中的A().a对象赋值</span></span><br><span class="line">        <span class="comment">## 获取值</span></span><br><span class="line">        print(my_test.a)</span><br><span class="line">        <span class="comment">## 改变值 </span></span><br><span class="line">        my_test.b = i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        Thread(target=job, args=(i,)).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> k, v <span class="keyword">in</span> l.__storage__.items():</span><br><span class="line">        print(k)</span><br><span class="line">        <span class="keyword">for</span> name, obj <span class="keyword">in</span> v.items():</span><br><span class="line">            print(name, obj.__dict__)</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>CS</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Python</tag>
        <tag>MagicMethod</tag>
        <tag>Local</tag>
      </tags>
  </entry>
  <entry>
    <title>2019.7.9 Summary</title>
    <url>/2019/07/09/2019.7.9%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>这里主要是想对接下来两个月的时间做一些具体的规划，主要还是分为两个部分：CS和GNSS部分 具体希望有两个部分：看书和项目<br><a id="more"></a></p>
<hr>
<p>CS书籍部分就直接参考：（那个从算法数据结构以及软件开发能力两方面进行描述的博客）</p>
<ul>
<li style="list-style: none"><input type="checkbox"> C语言程序设计书籍</li>
<li style="list-style: none"><input type="checkbox"> 深入理解计算机系统  </li>
</ul>
<p>GNSS书籍直接参考：（这部分主要参考轨道的书籍以及各种论文文献吧）</p>
<ul>
<li style="list-style: none"><input type="checkbox" checked> 那本轨道的书</li>
<li style="list-style: none"><input type="checkbox"> 通过老师出版的那本书掌握有关PPP及模糊度固定及PPP-RTK的相关内容</li>
<li style="list-style: none"><input type="checkbox"> 强哥发的一些有关轨道的论文</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>first</title>
    <url>/2018/09/07/first/</url>
    <content><![CDATA[<p>hello world! Welcome to my blog!<br>欢迎来到我的个人技术博客！</p>
]]></content>
  </entry>
  <entry>
    <title>Test Blog</title>
    <url>/2018/09/07/test_blog/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
